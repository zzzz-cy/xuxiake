{"ast":null,"code":"import { createCommentVNode as _createCommentVNode, renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, toDisplayString as _toDisplayString, normalizeClass as _normalizeClass, createElementVNode as _createElementVNode } from \"vue\";\nconst _hoisted_1 = {\n  class: \"page-container\"\n};\nconst _hoisted_2 = {\n  class: \"chapter-list\"\n};\nconst _hoisted_3 = [\"onClick\"];\nconst _hoisted_4 = {\n  class: \"page-content\"\n};\nconst _hoisted_5 = {\n  ref: \"mapContainer\",\n  class: \"map-container\"\n};\nconst _hoisted_6 = {\n  class: \"story-content\"\n};\nconst _hoisted_7 = {\n  id: \"place-impo-container\",\n  class: \"top-content\"\n};\nconst _hoisted_8 = [\"innerHTML\"];\nconst _hoisted_9 = {\n  id: \"place-info-container\",\n  class: \"bottom-content\"\n};\nconst _hoisted_10 = [\"innerHTML\"];\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_createCommentVNode(\" 左侧章节容器 \"), _createElementVNode(\"div\", _hoisted_2, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList($data.chapters, (chapter, index) => {\n    return _openBlock(), _createElementBlock(\"div\", {\n      key: index,\n      class: _normalizeClass([\"chapter-item\", {\n        active: $data.activeChapter === index\n      }]),\n      onClick: $event => $options.selectChapter(index)\n    }, _toDisplayString(chapter), 11 /* TEXT, CLASS, PROPS */, _hoisted_3);\n  }), 128 /* KEYED_FRAGMENT */))]), _createCommentVNode(\" 中间章节容器 \"), _createElementVNode(\"div\", _hoisted_4, [_createCommentVNode(\" 矢量容器 \"), _createElementVNode(\"div\", _hoisted_5, null, 512 /* NEED_PATCH */)]), _createCommentVNode(\" 右侧故事容器 \"), _createElementVNode(\"div\", _hoisted_6, [_createElementVNode(\"div\", _hoisted_7, [_createCommentVNode(\" 上面的内容 \"), _cache[0] || (_cache[0] = _createElementVNode(\"h3\", {\n    class: \"title\"\n  }, \"地点信息\", -1 /* HOISTED */)), _createElementVNode(\"p\", {\n    class: \"inner-content\",\n    innerHTML: $data.placeInfoDisplay\n  }, null, 8 /* PROPS */, _hoisted_8)]), _createElementVNode(\"div\", _hoisted_9, [_createCommentVNode(\" 下面的内容 \"), _cache[1] || (_cache[1] = _createElementVNode(\"h3\", {\n    class: \"title\"\n  }, \"重要事件\", -1 /* HOISTED */)), _createElementVNode(\"p\", {\n    class: \"inner-content\",\n    innerHTML: $data.placeImpoDisplay\n  }, null, 8 /* PROPS */, _hoisted_10)])])]);\n}","map":{"version":3,"names":["class","ref","id","_createElementBlock","_hoisted_1","_createCommentVNode","_createElementVNode","_hoisted_2","_Fragment","_renderList","$data","chapters","chapter","index","key","_normalizeClass","active","activeChapter","onClick","$event","$options","selectChapter","_hoisted_3","_hoisted_4","_hoisted_5","_hoisted_6","_hoisted_7","innerHTML","placeInfoDisplay","_hoisted_8","_hoisted_9","placeImpoDisplay","_hoisted_10"],"sources":["D:\\desk\\数据可视化\\project\\xuxiake\\src\\components\\PageOne.vue"],"sourcesContent":["<template>\n  <div class=\"page-container\">\n    <!-- 左侧章节容器 -->\n    <div class=\"chapter-list\">\n      <div\n        v-for=\"(chapter, index) in chapters\"\n        :key=\"index\"\n        class=\"chapter-item\"\n        :class=\"{ active: activeChapter === index }\"\n        @click=\"selectChapter(index)\"\n      >\n        {{ chapter }}\n      </div>\n    </div>\n    <!-- 中间章节容器 -->\n    <div class=\"page-content\">\n      <!-- 矢量容器 -->\n      <div ref=\"mapContainer\" class=\"map-container\"></div>\n    </div>\n    <!-- 右侧故事容器 -->   \n    <div class=\"story-content\">\n      <div id=\"place-impo-container\" class=\"top-content\">\n        <!-- 上面的内容 -->\n        <h3 class=\"title\">地点信息</h3>\n        <p class=\"inner-content\" v-html=\"placeInfoDisplay\"></p>\n      </div>\n      <div id=\"place-info-container\" class=\"bottom-content\">\n        <!-- 下面的内容 -->\n        <h3 class=\"title\">重要事件</h3>\n        <p class=\"inner-content\" v-html=\"placeImpoDisplay\"></p>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport * as d3 from \"d3\";\n\nexport default {\n  name: \"PageOne\",\n  data() {\n    return {\n      svg: null,        // SVG 对象\n      projection: null, // 存储地图投影对象\n\n      chapters: [], // 存储章节名\n      activeChapter: null, // 当前选中的章节索引\n\n      locations: [], // 存储地点信息\n      selectedLocations: [], // 存储选中的地点数据\n\n      timeData: [], // 存储有时间信息的数据\n      selectedTimeData: [], // 存储选中的时间数据\n\n      lines: [],  // 动态存储曲线数据\n\n      placeInfoDisplay: \"这里会显示地点信息\", // 默认信息\n      placeImpoDisplay: \"这里会显示重要事件信息\", // 默认信息.\", // 默认重要事件信息\n    };\n  },\n  async mounted() {\n    await Promise.all([\n      this.loadChapters(), // 异步加载章节数据\n      this.loadLocationData(), // 异步加载地点数据\n      this.loadTimeData(),// 异步加载时间数据\n    ]);\n    this.initMap();\n  },\n  methods: {\n    // 加载章节名\n    async loadChapters() {\n      try {\n        const response = await fetch(\"/data/chapters.json\"); // JSON 文件路径\n        const data = await response.json();\n        this.chapters = data.chapters;\n      } catch (error) {\n        console.error(\"Failed to load chapters:\", error);\n      }\n    },\n    // 提取时间中的第一个年份\n    extractDate(timeString) {\n      if (timeString == null) {\n        return new Date(1940, 0, 1); // 如果没有时间，默认为 1940 年 1 月 1 日\n      }\n\n      // 1. 提取年份（括号中的四位数字）\n      const yearRegex = /[（(](\\d{4})[）)]/;\n      const yearMatch = timeString.match(yearRegex); // 获取年份匹配结果\n      const year = yearMatch ? parseInt(yearMatch[1], 10) : 1940;  // 如果找到年份，返回年份，否则默认为 1940 年\n\n      // 2. 提取月份（如果有月字）\n      const monthRegex = /(\\d+)(?=月)/;  // 匹配数字和后面的\"月\"\n      const monthMatch = timeString.match(monthRegex);\n      const month = monthMatch ? parseInt(monthMatch[1], 10) - 1 : 0;  // 月份从0开始，没找到则默认为1月\n\n      // 3. 提取日期（如果有日字）\n      const dayRegex = /(\\d+)(?=日)/;  // 匹配数字和后面的\"日\"\n      const dayMatch = timeString.match(dayRegex);\n      const day = dayMatch ? parseInt(dayMatch[1], 10) : 1;  // 没找到则默认为1日\n\n      // 返回构造的日期对象\n      return new Date(year, month, day);  // 返回根据提取的年份、月份、日期生成的日期对象\n    },\n\n    // 加载地点数据\n    async loadLocationData() {\n      try {\n        const response = await fetch(\"/data/dataset_total.json\"); // 数据文件路径\n        const data = await response.json();\n        // 只提取地名和经纬度\n        this.locations = data.map(item => ({\n          name: item[\"地名\"],\n          lon: item[\"地点经度（默认东经）\"],\n          lat: item[\"地点纬度（默认北纬）\"],\n          chapter: item[\"所属篇目\"],  // 添加“所属篇目”字段\n          route: item[\"详细路线\"],    // 添加“详细路线”字段\n          // time: this.extractYear(item[\"游历时间\"])  // 提取年份\n        }));\n        \n      } catch (error) {\n        console.error(\"Failed to load location data:\", error);\n      }\n    },\n    // 加载时间数据\n    async loadTimeData() {\n      try {\n        const response = await fetch(\"/data/dataset_time.json\"); // 数据文件路径\n        const data = await response.json();\n        // 只提取地名和经纬度\n        this.timeData = data.map(item => ({\n          name: item[\"地名\"],\n          lon: item[\"地点经度（默认东经）\"],\n          lat: item[\"地点纬度（默认北纬）\"],\n          chapter: item[\"所属篇目\"],  // 添加“所属篇目”字段\n          route: item[\"详细路线\"],    // 添加“详细路线”字段\n          time: this.extractDate(item[\"游历时间\"]),  // 提取年份\n          info: item[\"地点信息补充（来自百科）\"],\n          impo: item[\"重要事件\"],\n        }));\n        console.log(\"Original data length:\", data.length);\n        console.log(\"Processed timeData length:\", this.timeData.length);\n\n      } catch (error) {\n        console.error(\"Failed to load location data:\", error);\n      }\n    },\n\n    // 选择章节\n    selectChapter(index) {\n      this.activeChapter = index;\n      const selectedChapter = this.chapters[index];\n      console.log(\"1\");\n      // 筛选出\"所属篇目\"为选中章节的数据\n      this.selectedLocations = this.locations.filter(item => item.chapter === selectedChapter);\n      // 筛选出\"所属篇目\"为选中章节的数据\n      this.selectedTimeData = this.timeData.filter(item => item.chapter === selectedChapter);\n      // 关联地点和时间数据\n      this.relate();\n    },\n    // 绘制地图路径\n    async drawMapPath(svg, projection) {\n      return new Promise((resolve, reject) => {\n        d3.json(\"/data/china.geo.json\").then(mapData => {\n          const path = d3.geoPath().projection(projection);\n          svg.append(\"g\")\n            .selectAll(\"path\")\n            .data(mapData.features)\n            .enter()\n            .append(\"path\")\n            .attr(\"d\", path)\n            .style(\"fill\", \"#404466\")\n            .on(\"mouseover\", (event, d) => {\n              d3.select(event.currentTarget).style(\"fill\", \"#2CD8FF\");\n              this.createTooltip(svg, d, event);\n            })\n            .on(\"mousemove\", (event) => {\n              this.removeTooltip();\n              this.createTooltip(svg, null, event);\n            })\n            .on(\"mouseout\", (event) => {\n              d3.select(event.currentTarget).style(\"fill\", \"#404466\");\n              this.removeTooltip();\n            });\n\n          // 绘制完成后调用 resolve\n          resolve();\n        }).catch(reject); // 如果失败，则调用 reject\n      });\n    },\n    // 在选择章节时关联地图上的点和时间标尺\n    async relate() {\n      const svg = d3.select(this.$refs.mapContainer).select(\"svg\");  // 选择地图的 svg 容器\n      svg.selectAll(\"circle\").remove();  // 清除之前绘制的地点圆圈\n      svg.selectAll(\".location-line\").remove();\n      svg.selectAll(\".tick\").remove();\n      // 高亮当前章节的地点，灰色其他地点\n      await this.drawLocationCircles(svg, this.projection, this.selectedLocations);\n      await this.drawLocationLines(svg, this.projection, this.selectedLocations);\n      \n      // 获取时间标尺容器的 g 元素\n      const timelineGroup = svg.select(\".timeline-group\");\n      \n      const timelineWidth = svg.node().getBoundingClientRect().width;\n      const timelineHeight = 60;  // 时间标尺的高度\n      // 1. 清除之前的时间连接线和时间点\n      svg.selectAll(\".timeline-link\").remove();\n      svg.selectAll(\".location-circle\").remove();  // 清除之前绘制的地点圆圈\n      timelineGroup.selectAll(\".timeline-point\").remove(); // axis-label清除之前的时间点\n      svg.selectAll(\".axis-label\").remove();\n      timelineGroup.selectAll(\".timeline-text\").remove();\n      // 清除之前绘制的时间轴\n      timelineGroup.select(\".timeline-axis\").remove();\n\n      // 时间数据范围\n      const minDate = d3.min(this.selectedTimeData, d => new Date(d.time));\n      const maxDate = d3.max(this.selectedTimeData, d => new Date(d.time));\n\n      // 计算时间跨度（以毫秒为单位）\n      const timeSpan = maxDate - minDate;\n\n      // 根据时间跨度动态调整最小和最大日期\n      let adjustedMinDate, adjustedMaxDate;\n      if (timeSpan <= 365 * 24 * 60 * 60 * 1000) {  // 小于一年\n        adjustedMinDate = d3.timeMonth.offset(minDate, -1);  // 最小日期为实际最小日期的前1个月\n        adjustedMaxDate = d3.timeMonth.offset(maxDate, 1);   // 最大日期为实际最大日期的后1个月\n      } else {  // 大于一年\n        adjustedMinDate = d3.timeYear.offset(minDate, -1);   // 最小日期为实际最小日期的前1年\n        adjustedMaxDate = d3.timeYear.offset(maxDate, 1);    // 最大日期为实际最大日期的后1年\n      }\n\n      // 2. 根据选中的时间数据，更新时间标尺\n      const xScale = d3.scaleTime()\n        .domain([adjustedMinDate, adjustedMaxDate])\n        .range([30, timelineWidth - 30]);\n\n      // 动态设置时间刻度的间隔\n      const interval = timeSpan <= 365 * 24 * 60 * 60 * 1000 // 小于一年\n        ? d3.timeMonth.every(1)  // 每月一个刻度\n        : d3.timeYear.every(1);  // 每年一个刻度\n\n      // 绘制时间轴刻度\n      const axisBottom = d3.axisBottom(xScale).ticks(interval).tickFormat(d3.timeFormat(\"%Y-%m\"));\n      timelineGroup.append(\"g\")\n          .attr(\"class\", \"timeline-axis\")\n          .attr(\"transform\", `translate(0, ${620 + timelineHeight / 2})`)\n          .call(axisBottom)\n          .selectAll(\".tick line\") // 修改刻度线的颜色\n          .attr(\"y1\", -30)\n          .attr(\"y2\", timelineHeight -30)\n          .style(\"stroke\", \"#8918cf4a\") // 红色\n          .style(\"stroke-width\", \"1\"); // 调整线宽\n\n      // 隐藏横轴线 (即 path 元素)\n      timelineGroup.select(\".timeline-axis path\")\n          .style(\"display\", \"none\"); // 隐藏横轴线\n\n      // 绘制时间轴上的每个点\n      timelineGroup.selectAll(\".timeline-point\")\n        .data(this.selectedTimeData)\n        .enter()\n        .append(\"circle\")\n        .attr(\"class\", \"timeline-point\")\n        .attr(\"cx\", (d, i) => {\n          const baseX = xScale(new Date(d.time)); // 根据时间绘制位置\n          const offsetX = i * 5;  // 根据索引为点添加水平偏移（你可以调整这个值）\n          return baseX + offsetX; // 添加偏移后的X坐标\n        })\n        .attr(\"cy\", 620 + timelineHeight / 2) // 在时间标尺中居中显示\n        .attr(\"r\", 6)\n        .attr(\"fill\", \"#FF0000\")\n        .style(\"opacity\", 0.7);      \n      // 2. 绘制时间文本\n      timelineGroup.selectAll(\".timeline-text\")\n        .data(this.selectedTimeData)\n        .enter()\n        .append(\"text\")\n        .attr(\"class\", \"timeline-text\")\n        .attr(\"x\", (d, i) => {\n          const baseX = xScale(new Date(d.time)); // 根据时间绘制位置\n          const offsetX = i * 5;  // 根据索引为点添加水平偏移\n          return baseX + offsetX;\n        })\n        .attr(\"y\", 640 + timelineHeight / 2) // 文字位置稍微在点的下方\n        .attr(\"dy\", -30) // 微调文字的垂直位置\n        .attr(\"text-anchor\", \"middle\") // 文字居中显示\n        .text(d => new Date(d.time).toLocaleDateString()) // 格式化时间为日期\n        .style(\"font-size\", \"12px\")\n        .style(\"fill\", \"#000000\");\n\n      // 3. 添加坐标轴名称（时间轴名称）\n      svg.append(\"text\")\n        .attr(\"class\", \"axis-label\")\n        .attr(\"x\", (timelineWidth *0.95))  // 将文本放置在画布的中心\n        .attr(\"y\", 650 + timelineHeight / 2) // 放置在时间轴下方\n        .attr(\"text-anchor\", \"middle\")\n        .text(\"时间轴\")  // 设置坐标轴的名称\n        .style(\"font-size\", \"16px\")\n        .style(\"font-weight\", \"bold\");\n\n      // 4. 绘制时间连接线（从每个地点到时间点）\n      const lineGroup = svg.append(\"g\").attr(\"class\", \"timeline-link\");\n\n\n      // 创建一个时间轴上的点与地图上地点之间的连接曲线\n      lineGroup.selectAll(\"path\")  // 使用path而不是line来绘制曲线\n          .data(this.selectedTimeData)\n          .enter()\n          .append(\"path\")\n          .attr(\"class\", \"timeline-link\")\n          .attr(\"d\", (d, i) => {\n            // 为终点添加偏移量，避免重叠\n            const offsetX = i * 5;  // 可以根据索引调整偏移量（例如 5px）\n            const offsetY = 0;  // 可以根据需要在y方向上加偏移，调整终点的y位置\n\n            // 定义曲线的起点和终点以及控制点\n            const start = [xScale(new Date(d.time)) + offsetX, 620 + timelineHeight / 2 + offsetY];  // 时间点的x坐标和y坐标\n            \n\n            // 地点的x坐标和y坐标，添加偏移量\n            const end = this.projection([d.lon, d.lat]);\n            \n\n            // 定义控制点用于绘制曲线 (你可以根据需要调整控制点的位置)\n            const controlPoint = [\n                (start[0] + end[0]) / 2, // 控制点的x坐标\n                (start[1] + end[1]) / 2 - 50  // 控制点的y坐标，偏移使曲线有弯曲\n            ];\n\n              // 使用贝塞尔曲线进行绘制\n            return d3.line().curve(d3.curveCardinal).x(d => d[0]).y(d => d[1])([start, controlPoint, end]);\n              // 曲线的起点、控制点和终点\n          })\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"#FF0000\")\n          .attr(\"stroke-width\", 2)\n          .style(\"opacity\", 0.5)\n          .style(\"stroke-dasharray\", \"4,4\");  // 添加虚线效果\n      // 绘制每个时间点下方的圆角矩形\n      const rectWidth = 30;  // 设置矩形宽度\n      const rectHeight = 80; // 设置矩形高度\n\n      lineGroup.selectAll(\".timeline-rect\")\n        .data(this.selectedTimeData)\n        .enter()\n        .append(\"rect\")\n        .attr(\"class\", \"timeline-rect\")\n        .attr(\"x\", (d, i) => {\n          const baseX = xScale(new Date(d.time)); // 根据时间绘制位置\n          const offsetX = i * 5;  // 根据索引为点添加水平偏移\n          return baseX + offsetX - rectWidth / 2; // 确保矩形居中\n        })\n        .attr(\"y\", (d, i) => {\n          const baseY = 750; // 根据时间绘制位置\n          const offsetY = (-1)**i * 60;  // 根据索引为每个矩形添加垂直偏移\n          return baseY + offsetY;  // 确保矩形有足够的垂直间距\n        })\n        .attr(\"width\", rectWidth)\n        .attr(\"height\", rectHeight)\n        .attr(\"rx\", 8)  // 圆角矩形\n        .attr(\"ry\", 8)\n        .attr(\"fill\", \"#FFD700\")\n        .on(\"click\", (event, d) => {  // 使用箭头函数\n          const placeImpo = d.impo;\n          const placeInfo = d.info;\n          this.placeImpoDisplay = placeImpo ? placeImpo : \"无\";\n          this.placeInfoDisplay = placeInfo ? placeInfo : \"无\";\n        \n        })\n        .on(\"mouseover\", function() {\n          d3.select(this)  // 选择当前的矩形\n            .transition()  // 添加过渡效果\n            .duration(300)  // 设置过渡时间为300ms\n            .attr(\"fill\", \"#FF6347\")  // 鼠标经过时改变矩形颜色\n            .attr(\"cursor\", \"pointer\")  // 改变鼠标光标为手形\n            .style(\"opacity\", 0.8);  // 改变透明度\n        })\n        .on(\"mouseout\", function() {\n          d3.select(this)  // 选择当前的矩形\n            .transition()  // 添加过渡效果\n            .duration(300)  // 设置过渡时间为300ms\n            .attr(\"fill\", \"#FFD700\")  // 恢复原来的颜色\n            .style(\"opacity\", 1);  // 恢复透明度\n        });\n\n\n      // 绘制每个矩形和时间点之间的连接线\n      lineGroup.selectAll(\".timeline-line\")\n        .data(this.selectedTimeData)\n        .enter()\n        .append(\"line\")\n        .attr(\"class\", \"timeline-line\")\n        .attr(\"x1\", (d, i) => {\n          const baseX = xScale(new Date(d.time)); // 时间点x坐标\n          const offsetX = i * 5;  // 水平偏移\n          return baseX + offsetX;\n        })\n        .attr(\"y1\", 620 + timelineHeight / 2) // 时间点y坐标\n        .attr(\"x2\", (d, i) => {\n          const baseX = xScale(new Date(d.time)); // 时间点x坐标\n          const offsetX = i * 5;  // 水平偏移\n          return baseX + offsetX;\n        })\n        .attr(\"y2\", (d, i) => {\n          const baseY = 750; // 根据时间绘制位置\n          const offsetY = (-1)**i * 60;  // 根据索引为每个矩形添加垂直偏移\n          return baseY + offsetY;  // 确保矩形有足够的垂直间距\n        })\n        .attr(\"stroke\", \"#FF0000\")\n        .attr(\"stroke-width\", 2)\n        .style(\"opacity\", 0.5);\n\n      // 在矩形中添加文本\n      lineGroup.selectAll(\".timeline-text\")\n        .data(this.selectedTimeData)\n        .enter()\n        .append(\"text\")\n        .attr(\"class\", \"timeline-text\")\n        .attr(\"x\", (d, i) => {\n          const baseX = xScale(new Date(d.time)); // 根据时间绘制位置\n          const offsetX = i * 5;  // 根据索引为点添加水平偏移\n          return baseX + offsetX;\n        })\n        .attr(\"y\", (d, i) => {\n          const baseY = 770; // 根据时间绘制位置\n          const offsetY = (-1)**i * 60;  // 根据索引为每个矩形添加垂直偏移\n          return baseY + offsetY;  // 确保矩形有足够的垂直间距\n        })\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"12px\")\n        .attr(\"fill\", \"#000\")\n        .text(d => d.name);  // 显示选中的name字段\n\n\n      console.log(\"Relating data completed\");\n    },\n\n    // 绘制地点圆圈\n    async drawLocationCircles(svg, projection, locations) {\n      return new Promise((resolve) => {\n        svg.append(\"g\")\n          .selectAll(\"circle\")\n          .data(this.locations)\n          .enter()\n          .append(\"circle\")\n          .attr(\"cx\", (d) => projection([d.lon, d.lat])[0]) // 经度和纬度转为坐标\n          .attr(\"cy\", (d) => projection([d.lon, d.lat])[1])\n          .attr(\"r\", 5) // 圆圈半径\n          .attr(\"fill\", d => {\n            // 如果该地点属于当前章节，显示为红色，否则为灰色\n            return locations.includes(d) ? \"#FF0000\" : \"#808080\";\n          }) // 圆圈颜色为红色\n          .on(\"click\", (d) => {\n            console.log(`Clicked on location: ${d.name}`);\n          });\n\n        // 圆圈绘制完成后调用 resolve\n        resolve();\n      });\n    },\n\n    // 绘制地点之间的连接线\n    async drawLocationLines(svg, projection, locations) {\n      return new Promise((resolve) => {\n        const lineGroup = svg.append(\"g\");\n        for (let i = 0; i < this.locations.length - 1; i++) {\n          const start = this.locations[i];\n          const end = this.locations[i + 1];\n          lineGroup.append(\"line\")\n            .attr(\"class\", \"location-line\") // 为每条线添加一个 class，便于后续清除\n            .attr(\"x1\", projection([start.lon, start.lat])[0])\n            .attr(\"y1\", projection([start.lon, start.lat])[1])\n            .attr(\"x2\", projection([end.lon, end.lat])[0])\n            .attr(\"y2\", projection([end.lon, end.lat])[1])\n            .attr(\"stroke\", locations.includes(start)&&locations.includes(end) ? \"#FF0000\" : \"#808080\")\n           // 线的颜色\n            .attr(\"stroke-width\", 2); // 线的宽度\n        }\n\n        // 连接线绘制完成后调用 resolve\n        resolve();\n      });\n    },\n    async initMap() {\n      // 地图容器宽高\n      const width = 1200; // 放大宽度\n      const height = 900; // 放大高度\n\n      // 定义地图投影\n      this.projection = d3.geoMercator()\n        .center([107, 31]) // 地图中心位置\n        .scale(750) // 设置缩放量\n        .translate([width / 2, height / 2 - 30]); // 设置平移量\n\n      // 创建 SVG\n      this.svg = d3\n          .select(this.$refs.mapContainer)\n          .append(\"svg\")\n          .attr(\"width\", width)\n          .attr(\"height\", height);\n\n      try {\n        // 调用绘制地图路径函数\n        await this.drawMapPath(this.svg, this.projection);\n        // 调用绘制地点圆圈函数\n        await this.drawLocationCircles(this.svg, this.projection, this.locations);\n        // 调用绘制连接线函数\n        await this.drawLocationLines(this.svg, this.projection, this.locations);\n\n        // 创建时间标尺，并放置在地图下方\n        this.initTimeline(this.svg, 600); // 添加到地图的 SVG 中\n      } catch (error) {\n        console.error(\"地图数据加载失败:\", error);\n      }\n    },\n    initTimeline(mapSvg, mapHeight) {\n      // 检查 mapSvg 是否有效\n      if (!mapSvg || !mapSvg.node()) {\n        console.error('SVG is not initialized correctly.');\n        return;\n      }\n      const svg = mapSvg.append(\"g\").attr(\"class\", \"timeline-group\");\n\n      const timelineWidth = mapSvg.node().getBoundingClientRect().width;\n      const timelineHeight = 60;  // 高度设置为固定的 60px\n\n      // 设置时间标尺的 y 坐标，使其位于地图下方\n      const timelineYPosition = mapHeight + 20; // 调整时间标尺的位置，放置在地图下方\n\n      // 创建一个时间轴的比例尺\n      const xScale = d3.scaleTime()\n        .domain([d3.min(this.timeData, d => new Date(d.time)),\n          d3.max(this.timeData, d => new Date(d.time))])\n        .range([0, timelineWidth]);\n\n      // 绘制时间线的路径\n      const line = d3.line()\n        .x(d => xScale(new Date(d.time)))  // 根据时间来定位位置\n        .y(timelineHeight / 2)  // 固定在垂直中心\n        .curve(d3.curveMonotoneX);  // 平滑曲线\n      svg.append(\"path\")\n        .data([this.timeData]) // 将所有地点数据作为路径\n        .attr(\"d\", line)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", \"#8918cfc9\")\n        .attr(\"stroke-width\", 3)\n        .attr(\"marker-end\", \"url(#arrow)\")  // 为路径添加箭头标记\n        .attr(\"transform\", `translate(0, ${timelineYPosition})`); // 设置时间标尺的位置\n\n      console.log(xScale(new Date(this.timeData[50].time))); // 打印时间对应的X坐标\n\n      // 可选：添加时间轴刻度\n      const ticks = xScale.ticks(d3.timeYear.every(1)); // 每年一格\n      svg.selectAll(\".tick\")\n        .data(ticks)\n        .enter().append(\"line\")\n        .attr(\"class\", \"tick\")\n        .attr(\"x1\", d => xScale(d))\n        .attr(\"x2\", d => xScale(d))\n        .attr(\"y1\", 0)\n        .attr(\"y2\", timelineHeight)\n        .attr(\"stroke\", \"#8918cf4a\")\n        .attr(\"stroke-width\", 1)\n        .attr(\"transform\", `translate(0, ${timelineYPosition})`); // 设置刻度的位置\n\n      // 定义箭头的marker\n      svg.append(\"defs\").append(\"marker\")\n        .attr(\"id\", \"arrow\")  // 给箭头设置ID\n        .attr(\"viewBox\", \"0 0 10 10\")  // 设置箭头的视口\n        .attr(\"refX\", 8)  // 设置箭头的位置偏移量\n        .attr(\"refY\", 5)  // 设置箭头的Y偏移量\n        .attr(\"markerWidth\", 4)  // 箭头宽度\n        .attr(\"markerHeight\", 4)  // 箭头高度\n        .attr(\"orient\", \"auto\")  // 自动旋转以适应路径\n        .attr(\"transform\", `translate(0, ${timelineYPosition})`) // 设置刻度的位置\n        .append(\"path\")\n        .attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\")  // 绘制箭头路径\n        .attr(\"fill\", \"#8918cfc9\");  // 设置箭头颜色\n        \n    },    \n\n    \n    createTooltip(svg, d, event) {\n      const { x, y } = this.mouseXY(svg, event);\n\n      svg\n        .append(\"rect\")\n        .attr(\"id\", \"tooltip-box\")\n        .attr(\"x\", x)\n        .attr(\"y\", y)\n        .attr(\"width\", 100)\n        .attr(\"height\", 40)\n        .attr(\"fill\", \"#000\")\n        .attr(\"opacity\", 0.6);\n\n      svg\n        .append(\"text\")\n        .attr(\"id\", \"tooltip-text\")\n        .attr(\"x\", x + 50)\n        .attr(\"y\", y + 25)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"font-size\", \"14px\")\n        .attr(\"fill\", \"#fff\")\n        .text(d ? d.properties.name : \"\");\n    },\n    removeTooltip() {\n      d3.select(\"#tooltip-box\").remove();\n      d3.select(\"#tooltip-text\").remove();\n    },\n    mouseXY(svg, event) {\n      const rect = svg.node().getBoundingClientRect();\n      return { x: event.clientX - rect.left, y: event.clientY - rect.top };\n    },\n  },\n};\n</script>\n\n<style scoped>\n.page-container {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;  /* 内容从左侧开始 */\n  width: 100%;\n  height: calc(100vh - 43px); \n  overflow: hidden;\n  margin-top: 43px;\n  margin-bottom: 2px;\n   /* 根据需要调整此值，避免与导航栏重叠 */\n  \n}\n.chapter-list {\n  display: flex;\n  flex-direction: column;\n  width: 250px;\n  height: 98%;\n  overflow-y: auto;\n  background-color: #ffadad;\n  border-right: 1px solid #ddd;\n  padding: 15px 0px;\n  box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);\n  flex-shrink: 0; /* 防止缩小 */\n}\n.chapter-item {\n  padding: 10px;\n  margin: 5px 10px 5px 12px;\n  border-radius: 8px;\n  background-color: #ffffff;\n  color: #333;\n  cursor: pointer;\n  transition: background-color 0.3s, color 0.3s;\n}\n.chapter-item:hover {\n  background-color: #e0f7fa;\n  color: #00796b;\n}\n\n.chapter-item.active {\n  background-color: #00796b;\n  color: #ffffff;\n}\n\n.page-content {\n  flex-direction: column;  /* 子容器上下排列 */\n  flex-grow: 1; /* 填充剩余空间 */\n  width: auto;  /* 不设置固定宽度 */\n  height: 100%;            /* 父容器占满可用空间 */\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  background-color: #8918cf4a;\n}\n.map-container {\n  margin: 0;\n  width: 100%; /* 使用百分比宽度适配父容器 */\n  height: 100%; /* 使用百分比高度适配父容器 */\n  overflow: hidden; /* 隐藏超出的部分 */\n  background-color: #41db3c4a;\n  z-index: 2;\n}\n.story-content{\n  flex-direction: column;  /* 子容器上下排列 */\n  width: 350px;\n  flex-shrink: 0; /* 防止缩小 */\n  height: 100%; \n  padding-right:40px; \n  padding: 45px 40px 45px 45px; /* 上、右、下、左的内边距 */\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  background-color: #3cbedb7a;\n}\n\n.top-content {\n  width: 100%;\n  height: 45%;\n  background-color: #f9f9f9;\n  margin-bottom: 15px; /* 为了分隔上下内容 */\n  overflow-y: auto;  /* 允许内容滚动 */\n}\n\n.bottom-content {\n  width: 100%;\n  height: 45%;\n  background-color: #f0f0f0;\n  overflow-y: auto;  /* 允许内容滚动 */\n}\n.inner-content{\n  font-size: 20px;\n  color: #333;\n  line-height: 2.0;\n  margin-bottom: 10px;\n  text-indent: 2em;  /* 首段空两格 */\n  overflow-y: auto;  /* 超过高度时出现滚动条 */\n}\n.title {\n  font-size: 36px;\n  text-align: center;\n  margin: 0 auto;\n}\n</style>\n"],"mappings":";;EACOA,KAAK,EAAC;AAAgB;;EAEpBA,KAAK,EAAC;AAAc;mBAH7B;;EAeSA,KAAK,EAAC;AAAc;;EAElBC,GAAG,EAAC,cAAc;EAACD,KAAK,EAAC;;;EAG3BA,KAAK,EAAC;AAAe;;EACnBE,EAAE,EAAC,sBAAsB;EAACF,KAAK,EAAC;;mBArB3C;;EA0BWE,EAAE,EAAC,sBAAsB;EAACF,KAAK,EAAC;;oBA1B3C;;uBACEG,mBAAA,CA+BM,OA/BNC,UA+BM,GA9BJC,mBAAA,YAAe,EACfC,mBAAA,CAUM,OAVNC,UAUM,I,kBATJJ,mBAAA,CAQMK,SAAA,QAZZC,WAAA,CAKmCC,KAAA,CAAAC,QAAQ,EAL3C,CAKgBC,OAAO,EAAEC,KAAK;yBADxBV,mBAAA,CAQM;MANHW,GAAG,EAAED,KAAK;MACXb,KAAK,EAPbe,eAAA,EAOc,cAAc;QAAAC,MAAA,EACFN,KAAA,CAAAO,aAAa,KAAKJ;MAAK;MACxCK,OAAK,EAAAC,MAAA,IAAEC,QAAA,CAAAC,aAAa,CAACR,KAAK;wBAExBD,OAAO,gCAXlBU,UAAA;oCAcIjB,mBAAA,YAAe,EACfC,mBAAA,CAGM,OAHNiB,UAGM,GAFJlB,mBAAA,UAAa,EACbC,mBAAA,CAAoD,OAApDkB,UAAoD,8B,GAEtDnB,mBAAA,YAAe,EACfC,mBAAA,CAWM,OAXNmB,UAWM,GAVJnB,mBAAA,CAIM,OAJNoB,UAIM,GAHJrB,mBAAA,WAAc,E,0BACdC,mBAAA,CAA2B;IAAvBN,KAAK,EAAC;EAAO,GAAC,MAAI,sBACtBM,mBAAA,CAAuD;IAApDN,KAAK,EAAC,eAAe;IAAC2B,SAAyB,EAAjBjB,KAAA,CAAAkB;0BAxBzCC,UAAA,E,GA0BMvB,mBAAA,CAIM,OAJNwB,UAIM,GAHJzB,mBAAA,WAAc,E,0BACdC,mBAAA,CAA2B;IAAvBN,KAAK,EAAC;EAAO,GAAC,MAAI,sBACtBM,mBAAA,CAAuD;IAApDN,KAAK,EAAC,eAAe;IAAC2B,SAAyB,EAAjBjB,KAAA,CAAAqB;0BA7BzCC,WAAA,E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}